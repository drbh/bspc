//! Matrix operations and views for memory-mapped sparse matrices
//!
//! This module provides matrix operations, views, and iterators for working with sparse matrices.

use super::mmap_core::{MatrixElement, MmapMatrix};
use binsparse_rs::{array::ArrayValue, Error, Result};
use bspc_core::{DataType, MatrixFormat, SparseMatrix};
use std::collections::HashMap;

/// Macro to generate repetitive method implementations for DynamicMatrix
macro_rules! impl_dynamic_method {
    ($method:ident -> $return_type:ty) => {
        pub fn $method(&self) -> $return_type {
            match self {
                DynamicMatrix::F32(m) => m.$method(),
                DynamicMatrix::F64(m) => m.$method(),
                DynamicMatrix::I32(m) => m.$method(),
                DynamicMatrix::I64(m) => m.$method(),
                DynamicMatrix::U32(m) => m.$method(),
                DynamicMatrix::U64(m) => m.$method(),
            }
        }
    };

    ($method:ident($($param:ident: $param_type:ty),*) -> $return_type:ty) => {
        pub fn $method(&self, $($param: $param_type),*) -> $return_type {
            match self {
                DynamicMatrix::F32(m) => m.$method($($param),*),
                DynamicMatrix::F64(m) => m.$method($($param),*),
                DynamicMatrix::I32(m) => m.$method($($param),*),
                DynamicMatrix::I64(m) => m.$method($($param),*),
                DynamicMatrix::U32(m) => m.$method($($param),*),
                DynamicMatrix::U64(m) => m.$method($($param),*),
            }
        }
    };
}

/// Dynamic matrix that can hold any element type
/// Uses efficient enum dispatch for runtime type handling
#[cfg(feature = "mmap")]
pub enum DynamicMatrix {
    F32(MmapMatrix<f32>),
    F64(MmapMatrix<f64>),
    I32(MmapMatrix<i32>),
    I64(MmapMatrix<i64>),
    U32(MmapMatrix<u32>),
    U64(MmapMatrix<u64>),
}

#[cfg(feature = "mmap")]
impl DynamicMatrix {
    // Basic properties - generated by macro
    impl_dynamic_method!(nrows -> usize);
    impl_dynamic_method!(ncols -> usize);
    impl_dynamic_method!(nnz -> usize);
    impl_dynamic_method!(format -> MatrixFormat);
    impl_dynamic_method!(data_type -> DataType);

    // Element access methods
    impl_dynamic_method!(get_element(row: usize, col: usize) -> Result<Option<ArrayValue>>);

    // Row/column access methods
    impl_dynamic_method!(get_row(row: usize) -> Result<Vec<(usize, ArrayValue)>>);
    impl_dynamic_method!(get_col(col: usize) -> Result<Vec<(usize, ArrayValue)>>);
    impl_dynamic_method!(get_row_range(start_row: usize, end_row: usize) -> Result<Vec<(usize, usize, ArrayValue)>>);
    impl_dynamic_method!(get_col_range(start_col: usize, end_col: usize) -> Result<Vec<(usize, usize, ArrayValue)>>);
    impl_dynamic_method!(get_row_with_col_range(row: usize, start_col: usize, end_col: usize) -> Result<Vec<(usize, ArrayValue)>>);

    // Metadata methods
    impl_dynamic_method!(metadata_bytes -> Option<&[u8]>);
    impl_dynamic_method!(metadata_view -> Result<Option<crate::metadata::MetadataView<'_>>>);
    impl_dynamic_method!(row_label(row_idx: u32) -> Result<Option<&[u8]>>);
    impl_dynamic_method!(col_label(col_idx: u32) -> Result<Option<&[u8]>>);

    /// Get row view iterator with zero-copy access
    pub fn row_view(
        &self,
        row: usize,
    ) -> Result<Box<dyn Iterator<Item = (usize, ArrayValue)> + '_>> {
        macro_rules! row_view_impl {
            ($matrix:expr) => {{
                let iter = $matrix
                    .row_view(row)?
                    .map(|(col, val)| (col, val.to_array_value()));
                Ok(Box::new(iter))
            }};
        }

        match self {
            DynamicMatrix::F32(m) => row_view_impl!(m),
            DynamicMatrix::F64(m) => row_view_impl!(m),
            DynamicMatrix::I32(m) => row_view_impl!(m),
            DynamicMatrix::I64(m) => row_view_impl!(m),
            DynamicMatrix::U32(m) => row_view_impl!(m),
            DynamicMatrix::U64(m) => row_view_impl!(m),
        }
    }

    /// Get column view iterator with zero-copy access
    pub fn col_view(
        &self,
        col: usize,
    ) -> Result<Box<dyn Iterator<Item = (usize, ArrayValue)> + '_>> {
        macro_rules! col_view_impl {
            ($matrix:expr) => {{
                let iter = $matrix
                    .col_view(col)?
                    .map(|(row, val)| (row, val.to_array_value()));
                Ok(Box::new(iter))
            }};
        }

        match self {
            DynamicMatrix::F32(m) => col_view_impl!(m),
            DynamicMatrix::F64(m) => col_view_impl!(m),
            DynamicMatrix::I32(m) => col_view_impl!(m),
            DynamicMatrix::I64(m) => col_view_impl!(m),
            DynamicMatrix::U32(m) => col_view_impl!(m),
            DynamicMatrix::U64(m) => col_view_impl!(m),
        }
    }

    /// Get efficient row range iterator that processes multiple rows in a single pass
    pub fn row_range_view(
        &self,
        start_row: usize,
        end_row: usize,
    ) -> Result<Box<dyn Iterator<Item = (usize, usize, ArrayValue)> + '_>> {
        macro_rules! row_range_view_impl {
            ($matrix:expr) => {{
                let iter = $matrix
                    .row_range_view(start_row, end_row)?
                    .map(|(row, col, val)| (row, col, val.to_array_value()));
                Ok(Box::new(iter))
            }};
        }

        match self {
            DynamicMatrix::F32(m) => row_range_view_impl!(m),
            DynamicMatrix::F64(m) => row_range_view_impl!(m),
            DynamicMatrix::I32(m) => row_range_view_impl!(m),
            DynamicMatrix::I64(m) => row_range_view_impl!(m),
            DynamicMatrix::U32(m) => row_range_view_impl!(m),
            DynamicMatrix::U64(m) => row_range_view_impl!(m),
        }
    }

    /// Get iterator over all rows in the matrix
    pub fn rows(&self) -> DynamicMatrixRowIterator<'_> {
        DynamicMatrixRowIterator {
            matrix: self,
            current_row: 0,
            total_rows: self.nrows(),
        }
    }
}

/// Iterator over all rows in a DynamicMatrix
pub struct DynamicMatrixRowIterator<'a> {
    matrix: &'a DynamicMatrix,
    current_row: usize,
    total_rows: usize,
}

impl<'a> Iterator for DynamicMatrixRowIterator<'a> {
    type Item = (
        usize,
        Result<Box<dyn Iterator<Item = (usize, ArrayValue)> + 'a>>,
    );

    fn next(&mut self) -> Option<Self::Item> {
        if self.current_row >= self.total_rows {
            return None;
        }

        let row_index = self.current_row;
        self.current_row += 1;

        Some((row_index, self.matrix.row_view(row_index)))
    }
}

impl<'a> ExactSizeIterator for DynamicMatrixRowIterator<'a> {
    fn len(&self) -> usize {
        self.total_rows.saturating_sub(self.current_row)
    }
}

/// Dynamic element type that can represent any matrix element
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum DynamicElement {
    F32(f32),
    F64(f64),
    I32(i32),
    I64(i64),
    U32(u32),
    U64(u64),
}

// Implement bspc_core::MatrixElement for DynamicElement
impl bspc_core::MatrixElement for DynamicElement {
    fn data_type() -> bspc_core::DataType {
        bspc_core::DataType::F64 // Default to F64
    }
    
    fn from_f64(value: f64) -> Self {
        DynamicElement::F64(value)
    }
    
    fn to_f64(self) -> f64 {
        match self {
            DynamicElement::F32(v) => v as f64,
            DynamicElement::F64(v) => v,
            DynamicElement::I32(v) => v as f64,
            DynamicElement::I64(v) => v as f64,
            DynamicElement::U32(v) => v as f64,
            DynamicElement::U64(v) => v as f64,
        }
    }
}

// Implement local MatrixElement for DynamicElement
impl MatrixElement for DynamicElement {
    fn to_array_value(self) -> ArrayValue {
        match self {
            DynamicElement::F32(v) => ArrayValue::Float32(v),
            DynamicElement::F64(v) => ArrayValue::Float64(v),
            DynamicElement::I32(v) => ArrayValue::Int32(v),
            DynamicElement::I64(v) => ArrayValue::Int64(v),
            DynamicElement::U32(v) => ArrayValue::UInt32(v),
            DynamicElement::U64(v) => ArrayValue::UInt64(v),
        }
    }

    fn from_le_bytes(bytes: &[u8]) -> Result<Self> {
        if bytes.len() >= 8 {
            let value = f64::from_le_bytes([
                bytes[0], bytes[1], bytes[2], bytes[3],
                bytes[4], bytes[5], bytes[6], bytes[7],
            ]);
            Ok(DynamicElement::F64(value))
        } else if bytes.len() >= 4 {
            let value = f32::from_le_bytes([bytes[0], bytes[1], bytes[2], bytes[3]]);
            Ok(DynamicElement::F32(value))
        } else {
            Err(Error::InvalidState("Not enough bytes for DynamicElement"))
        }
    }

    fn to_le_bytes(self) -> Vec<u8> {
        match self {
            DynamicElement::F32(v) => v.to_le_bytes().to_vec(),
            DynamicElement::F64(v) => v.to_le_bytes().to_vec(),
            DynamicElement::I32(v) => v.to_le_bytes().to_vec(),
            DynamicElement::I64(v) => v.to_le_bytes().to_vec(),
            DynamicElement::U32(v) => v.to_le_bytes().to_vec(),
            DynamicElement::U64(v) => v.to_le_bytes().to_vec(),
        }
    }
}

impl DynamicElement {
    /// Convert from ArrayValue
    pub fn from_array_value(value: ArrayValue) -> Self {
        match value {
            ArrayValue::Float32(v) => DynamicElement::F32(v),
            ArrayValue::Float64(v) => DynamicElement::F64(v),
            ArrayValue::Int32(v) => DynamicElement::I32(v),
            ArrayValue::Int64(v) => DynamicElement::I64(v),
            ArrayValue::UInt32(v) => DynamicElement::U32(v),
            ArrayValue::UInt64(v) => DynamicElement::U64(v),
            // Convert other types to appropriate equivalents
            ArrayValue::UInt8(v) => DynamicElement::U32(v as u32),
            ArrayValue::UInt16(v) => DynamicElement::U32(v as u32),
            ArrayValue::Int8(v) => DynamicElement::I32(v as i32),
            ArrayValue::Int16(v) => DynamicElement::I32(v as i32),
            ArrayValue::BInt8(v) => DynamicElement::I32(v as i32),
        }
    }
}

// Implement SparseMatrix for DynamicMatrix using DynamicElement as the element type
#[cfg(feature = "mmap")]
impl SparseMatrix for DynamicMatrix {
    type Element = DynamicElement;

    fn get_element(&self, row: usize, col: usize) -> Option<Self::Element> {
        self.get_element(row, col).ok().flatten()
            .map(DynamicElement::from_array_value)
    }

    fn dimensions(&self) -> (usize, usize) {
        (self.nrows(), self.ncols())
    }

    fn nnz(&self) -> usize {
        self.nnz()
    }
}

/// View for matrix subregions (simplified for production)
pub struct SubmatrixView<T: MatrixElement> {
    elements: HashMap<(usize, usize), T>,
}

impl<T: MatrixElement> SubmatrixView<T> {
    pub fn new(
        matrix: &MmapMatrix<T>,
        rows: std::ops::Range<usize>,
        cols: std::ops::Range<usize>,
    ) -> Result<Self> {
        // Validate row and column ranges
        if rows.end > matrix.nrows() {
            return Err(Error::InvalidState("Row range exceeds matrix dimensions"));
        }
        if cols.end > matrix.ncols() {
            return Err(Error::InvalidState(
                "Column range exceeds matrix dimensions",
            ));
        }
        if rows.is_empty() || cols.is_empty() {
            return Err(Error::InvalidState("Empty range not allowed"));
        }

        let mut elements = HashMap::new();
        let values = matrix.values();
        let row_indices = matrix.row_indices();
        let col_indices = matrix.col_indices();

        for i in 0..values.len() {
            let file_row = row_indices[i] as usize;
            let file_col = col_indices[i] as usize;

            // Validate file indices
            if file_row >= matrix.nrows() {
                return Err(Error::InvalidState(
                    "Corrupted data: row index exceeds matrix dimensions",
                ));
            }
            if file_col >= matrix.ncols() {
                return Err(Error::InvalidState(
                    "Corrupted data: column index exceeds matrix dimensions",
                ));
            }

            if rows.contains(&file_row) && cols.contains(&file_col) {
                elements.insert((file_row - rows.start, file_col - cols.start), values[i]);
            }
        }

        Ok(Self { elements })
    }

    pub fn get(&self, row: usize, col: usize) -> Option<T> {
        self.elements.get(&(row, col)).copied()
    }

    pub fn set(&mut self, row: usize, col: usize, value: T) -> Result<()> {
        self.elements.insert((row, col), value);
        Ok(())
    }

    pub fn get_as_array_value(&self, row: usize, col: usize) -> Option<ArrayValue> {
        self.elements.get(&(row, col)).map(|v| v.to_array_value())
    }
}

// Add view methods to MmapMatrix
#[cfg(feature = "mmap")]
impl<T: MatrixElement> MmapMatrix<T> {
    /// Binary search for element position in sorted COO format
    fn find_element_index(&self, row: usize, col: usize) -> Option<usize> {
        let values = self.values();
        let row_indices = self.row_indices();
        let col_indices = self.col_indices();
        let len = values.len();

        // Verify data integrity
        if len != row_indices.len() || len != col_indices.len() {
            return None;
        }

        // Binary search using combined key
        let target = (row as u64) << 32 | (col as u64);
        let mut left = 0;
        let mut right = len;

        while left < right {
            let mid = left + (right - left) / 2;
            let current = unsafe {
                ((*row_indices.get_unchecked(mid) as u64) << 32)
                    | (*col_indices.get_unchecked(mid) as u64)
            };

            if current < target {
                left = mid + 1;
            } else {
                right = mid;
            }
        }

        // Check if found
        if left < len {
            let found_row = unsafe { *row_indices.get_unchecked(left) } as usize;
            let found_col = unsafe { *col_indices.get_unchecked(left) } as usize;
            (found_row == row && found_col == col).then_some(left)
        } else {
            None
        }
    }

    /// Get element at specific position with optimized bounds checking
    pub fn get_element(&self, row: usize, col: usize) -> Result<Option<ArrayValue>> {
        // Bounds check
        if row >= self.nrows() || col >= self.ncols() {
            return Err(Error::InvalidState("Index out of bounds"));
        }

        // Bloom filter early exit
        if let Some(ref bloom_filter) = self.chunk_bloom_filter {
            if !bloom_filter.may_contain_row(row) {
                return Ok(None);
            }
        }

        // Find and return element
        Ok(self
            .find_element_index(row, col)
            .map(|idx| unsafe { self.values().get_unchecked(idx).to_array_value() }))
    }

    /// Get row view with zero-copy iterator
    pub fn row_view(&self, row: usize) -> Result<impl Iterator<Item = (usize, &T)> + '_> {
        if row >= self.nrows() {
            return Err(Error::InvalidState("Row index out of bounds"));
        }

        let values = self.values();
        let row_indices = self.row_indices();
        let col_indices = self.col_indices();

        Ok((0..values.len()).filter_map(move |i| {
            let file_row = row_indices[i] as usize;
            let file_col = col_indices[i] as usize;

            if file_row == row && file_col < self.ncols() {
                Some((file_col, &values[i]))
            } else {
                None
            }
        }))
    }

    /// Create a submatrix view
    pub fn submatrix_view(
        &self,
        rows: std::ops::Range<usize>,
        cols: std::ops::Range<usize>,
    ) -> Result<SubmatrixView<T>> {
        SubmatrixView::new(self, rows, cols)
    }

    /// Get column view with zero-copy iterator
    pub fn col_view(&self, col: usize) -> Result<impl Iterator<Item = (usize, &T)> + '_> {
        if col >= self.ncols() {
            return Err(Error::InvalidState("Column index out of bounds"));
        }

        let values = self.values();
        let row_indices = self.row_indices();
        let col_indices = self.col_indices();

        Ok((0..values.len()).filter_map(move |i| {
            let file_row = row_indices[i] as usize;
            let file_col = col_indices[i] as usize;

            if file_col == col && file_row < self.nrows() {
                Some((file_row, &values[i]))
            } else {
                None
            }
        }))
    }

    /// Get efficient row range iterator that processes multiple rows in a single pass
    /// Uses chunk-level bloom filtering to skip chunks that don't contain data in the range
    pub fn row_range_view(
        &self,
        start_row: usize,
        end_row: usize,
    ) -> Result<Box<dyn Iterator<Item = (usize, usize, &T)> + '_>> {
        // Validate row range
        if start_row >= self.nrows() || end_row > self.nrows() || start_row >= end_row {
            return Err(Error::InvalidState("Invalid row range"));
        }

        let values = self.values();
        let row_indices = self.row_indices();
        let col_indices = self.col_indices();

        // Use chunk bloom filter if available for efficient filtering
        if let Some(ref bloom_filter) = self.chunk_bloom_filter {
            let relevant_chunks = bloom_filter.may_contain_range(start_row, end_row);

            // Early return if no chunks contain data in the range
            if relevant_chunks.is_empty() {
                return Ok(Box::new((0..0).filter_map(move |_| None)));
            }

            // Convert chunk indices to row ranges for efficient filtering
            let chunk_size = bloom_filter.chunk_size();
            let mut relevant_row_ranges = Vec::new();

            for chunk_idx in relevant_chunks {
                let chunk_start = chunk_idx * chunk_size;
                let chunk_end = ((chunk_idx + 1) * chunk_size).min(self.nrows());

                // Only include the intersection with the requested range
                let range_start = start_row.max(chunk_start);
                let range_end = end_row.min(chunk_end);

                if range_start < range_end {
                    relevant_row_ranges.push(range_start..range_end);
                }
            }

            // Filter elements that fall within relevant chunks
            Ok(Box::new((0..values.len()).filter_map(move |i| {
                let file_row = row_indices[i] as usize;
                let file_col = col_indices[i] as usize;

                // Check if row is in any relevant chunk range
                let in_relevant_chunk = relevant_row_ranges
                    .iter()
                    .any(|range| range.contains(&file_row));

                if in_relevant_chunk
                    && file_row >= start_row
                    && file_row < end_row
                    && file_row < self.nrows()
                    && file_col < self.ncols()
                {
                    Some((file_row, file_col, &values[i]))
                } else {
                    None
                }
            })))
        } else {
            // Fallback: Linear scan when no bloom filter available
            Ok(Box::new((0..values.len()).filter_map(move |i| {
                let file_row = row_indices[i] as usize;
                let file_col = col_indices[i] as usize;

                if file_row >= start_row
                    && file_row < end_row
                    && file_row < self.nrows()
                    && file_col < self.ncols()
                {
                    Some((file_row, file_col, &values[i]))
                } else {
                    None
                }
            })))
        }
    }

    /// Get a range of rows efficiently
    pub fn get_row_range(
        &self,
        start_row: usize,
        end_row: usize,
    ) -> Result<Vec<(usize, usize, ArrayValue)>> {
        if start_row >= self.nrows() || end_row > self.nrows() || start_row >= end_row {
            return Err(Error::InvalidState("Invalid row range"));
        }

        let values = self.values();
        let row_indices = self.row_indices();
        let col_indices = self.col_indices();
        let mut results = Vec::new();

        // Use chunk bloom filter if available
        let should_scan = if let Some(ref bloom_filter) = self.chunk_bloom_filter {
            !bloom_filter
                .may_contain_range(start_row, end_row)
                .is_empty()
        } else {
            true
        };

        if should_scan {
            for i in 0..values.len() {
                let file_row = row_indices[i] as usize;
                let file_col = col_indices[i] as usize;

                if file_row >= start_row && file_row < end_row && file_col < self.ncols() {
                    results.push((file_row, file_col, values[i].to_array_value()));
                }
            }
        }

        Ok(results)
    }

    /// Get a specific row (returns Vec similar to http_backend)
    pub fn get_row(&self, row: usize) -> Result<Vec<(usize, ArrayValue)>> {
        let elements = self.get_row_range(row, row + 1)?;
        Ok(elements
            .into_iter()
            .map(|(_, col, value)| (col, value))
            .collect())
    }

    /// Get a specific row with column range filter
    pub fn get_row_with_col_range(
        &self,
        row: usize,
        start_col: usize,
        end_col: usize,
    ) -> Result<Vec<(usize, ArrayValue)>> {
        if row >= self.nrows() {
            return Err(Error::InvalidState("Row index out of bounds"));
        }
        if start_col >= self.ncols() || end_col > self.ncols() || start_col >= end_col {
            return Err(Error::InvalidState("Invalid column range"));
        }

        // Use chunk bloom filter if available
        if let Some(ref bloom_filter) = self.chunk_bloom_filter {
            if !bloom_filter.may_contain_row(row) {
                return Ok(Vec::new());
            }
        }

        let elements = self.get_row_range(row, row + 1)?;
        Ok(elements
            .into_iter()
            .filter(|(_, col, _)| *col >= start_col && *col < end_col)
            .map(|(_, col, value)| (col, value))
            .collect())
    }

    /// Get a column range efficiently
    pub fn get_col_range(
        &self,
        start_col: usize,
        end_col: usize,
    ) -> Result<Vec<(usize, usize, ArrayValue)>> {
        if start_col >= self.ncols() || end_col > self.ncols() || start_col >= end_col {
            return Err(Error::InvalidState("Invalid column range"));
        }

        let values = self.values();
        let row_indices = self.row_indices();
        let col_indices = self.col_indices();
        let mut results = Vec::new();

        for i in 0..values.len() {
            let file_row = row_indices[i] as usize;
            let file_col = col_indices[i] as usize;

            if file_row < self.nrows() && file_col >= start_col && file_col < end_col {
                results.push((file_row, file_col, values[i].to_array_value()));
            }
        }

        Ok(results)
    }

    /// Get a specific column
    pub fn get_col(&self, col: usize) -> Result<Vec<(usize, ArrayValue)>> {
        let elements = self.get_col_range(col, col + 1)?;
        Ok(elements
            .into_iter()
            .map(|(row, _, value)| (row, value))
            .collect())
    }

    /// Get metadata bytes from the memory-mapped file
    /// Returns None if no metadata is present
    pub fn metadata_bytes(&self) -> Option<&[u8]> {
        if let Some((offset, size)) = self.header.metadata_region() {
            // Validate offset and size against memory map bounds
            let start = offset as usize;
            let end = start.checked_add(size as usize)?;

            if end <= self._mmap.len() {
                Some(&self._mmap[start..end])
            } else {
                None
            }
        } else {
            None
        }
    }

    /// Get structured metadata view for fast label lookups
    pub fn metadata_view(&self) -> Result<Option<crate::metadata::MetadataView<'_>>> {
        if let Some(metadata_bytes) = self.metadata_bytes() {
            Ok(Some(crate::metadata::MetadataView::new(metadata_bytes)?))
        } else {
            Ok(None)
        }
    }

    /// Get row label by index
    pub fn row_label(&self, row_idx: u32) -> Result<Option<&[u8]>> {
        let Some(metadata_bytes) = self.metadata_bytes() else {
            return Ok(None);
        };

        let header = crate::metadata::BspcMetadataHeader::from_bytes(metadata_bytes)
            .map_err(|_| Error::InvalidState("Invalid metadata header"))?;
        if header.row_labels_size == 0 {
            return Ok(None);
        }

        let start = header.row_labels_offset as usize;
        let end = start + header.row_labels_size as usize;
        if end > metadata_bytes.len() {
            return Err(Error::InvalidState("Row labels extend beyond metadata"));
        }

        let labels_data = &metadata_bytes[start..end];
        let labels_array = crate::metadata::LabelArray::from_bytes(labels_data)?;
        if row_idx >= labels_array.count() {
            return Err(Error::InvalidState("Row index out of bounds"));
        }

        let label_start = bspc_core::format::constants::metadata::LABEL_ARRAY_HEADER_SIZE
            + (row_idx as usize * labels_array.stride() as usize);
        let label_end = label_start + labels_array.stride() as usize;
        if label_end > labels_data.len() {
            return Err(Error::InvalidState("Row label extends beyond data"));
        }

        Ok(Some(&labels_data[label_start..label_end]))
    }

    /// Get column label by index
    pub fn col_label(&self, col_idx: u32) -> Result<Option<&[u8]>> {
        let Some(metadata_bytes) = self.metadata_bytes() else {
            return Ok(None);
        };

        let header = crate::metadata::BspcMetadataHeader::from_bytes(metadata_bytes)
            .map_err(|_| Error::InvalidState("Invalid metadata header"))?;
        if header.col_labels_size == 0 {
            return Ok(None);
        }

        let start = header.col_labels_offset as usize;
        let end = start + header.col_labels_size as usize;
        if end > metadata_bytes.len() {
            return Err(Error::InvalidState("Column labels extend beyond metadata"));
        }

        let labels_data = &metadata_bytes[start..end];
        let labels_array = crate::metadata::LabelArray::from_bytes(labels_data)?;
        if col_idx >= labels_array.count() {
            return Err(Error::InvalidState("Column index out of bounds"));
        }

        let label_start = bspc_core::format::constants::metadata::LABEL_ARRAY_HEADER_SIZE
            + (col_idx as usize * labels_array.stride() as usize);
        let label_end = label_start + labels_array.stride() as usize;
        if label_end > labels_data.len() {
            return Err(Error::InvalidState("Column label extends beyond data"));
        }

        Ok(Some(&labels_data[label_start..label_end]))
    }
}

// Implement SparseMatrix for MmapMatrix
#[cfg(feature = "mmap")]
impl<T: MatrixElement + bspc_core::MatrixElement> SparseMatrix for MmapMatrix<T> {
    type Element = T;

    fn get_element(&self, row: usize, col: usize) -> Option<Self::Element> {
        // Use the typed get_element_typed method if available, otherwise convert from ArrayValue
        match self.get_element(row, col) {
            Ok(Some(array_value)) => {
                // Convert ArrayValue to T - this is a simplified conversion
                // In practice, you'd want a more robust conversion based on the actual types
                match array_value {
                    ArrayValue::Float32(val) if core::any::TypeId::of::<T>() == core::any::TypeId::of::<f32>() => {
                        // SAFETY: We've checked the type matches
                        unsafe { Some(*((&val as *const f32) as *const T)) }
                    },
                    ArrayValue::Float64(val) if core::any::TypeId::of::<T>() == core::any::TypeId::of::<f64>() => {
                        // SAFETY: We've checked the type matches
                        unsafe { Some(*((&val as *const f64) as *const T)) }
                    },
                    ArrayValue::Int32(val) if core::any::TypeId::of::<T>() == core::any::TypeId::of::<i32>() => {
                        // SAFETY: We've checked the type matches
                        unsafe { Some(*((&val as *const i32) as *const T)) }
                    },
                    ArrayValue::Int64(val) if core::any::TypeId::of::<T>() == core::any::TypeId::of::<i64>() => {
                        // SAFETY: We've checked the type matches
                        unsafe { Some(*((&val as *const i64) as *const T)) }
                    },
                    ArrayValue::UInt32(val) if core::any::TypeId::of::<T>() == core::any::TypeId::of::<u32>() => {
                        // SAFETY: We've checked the type matches
                        unsafe { Some(*((&val as *const u32) as *const T)) }
                    },
                    ArrayValue::UInt64(val) if core::any::TypeId::of::<T>() == core::any::TypeId::of::<u64>() => {
                        // SAFETY: We've checked the type matches
                        unsafe { Some(*((&val as *const u64) as *const T)) }
                    },
                    _ => None, // Type mismatch or unsupported conversion
                }
            },
            _ => None,
        }
    }

    fn dimensions(&self) -> (usize, usize) {
        (self.nrows(), self.ncols())
    }

    fn nnz(&self) -> usize {
        self.nnz()
    }
}
